**C++函数特性**

```c
在C++中允许在声明函数时，为函数的某些参数指定默认值。
void print(int value, int base=10); //声明
print(28); //28传给value；10传给base
print(32, 2); //32传给value；2传给base

```

**switch用法**

```c
int day;
switch(day)
{
    case 0:cout<<'0';break;
    case 1:cout<<'1';break;
    default:cout<<"error";
}
如：case 'A'
//switch 语句中的 expression 必须是一个整型或枚举类型，或者是一个 class 类型，（可以是字符类型，但不能是浮点类型、字符串、指针类型等）其中 class 有一个单一的转换函数将其转换为整型或枚举类型。

//循环
do
{
  
}while();
```

**数据类型**

```c
// =========== 立即数 ===============
    1，默认是int型
    1U，是无符号整数
    0x1f3，好像是无符号,后面也可加U，只是起强调作用
    0b101，好像是无符号，后面也可加U，只是起强调作用
    (对无符号数右移，前面补0；对有符号数右移，则前面全补符号位)


//32位二进制数 对应 8位16进制数
字长：在同一时间中处理二进制数的位数叫字长。二进制的每一个0或1是组成二进制的最小单位,称为一个比特（bit）。

字节 byte 8位2进制数
字  一台8位机，它的1个字就等于1个字节，字长为8位。如果是16位机，1个字就由2个字节构成，字长为16位。
KB=1024字节 

Tips：机器操作数据的最小单位是byte而不是bit，所以cpu/内存等设备的各种地址表示是指字节的编号(第n个字节，)。如int指针指向的地址为0xfff8,指针+1指向下一个int数据的位置，即0xfff4，表示移动了4个字节。

不同机器平台总结！！
https://www.cnblogs.com/soul-stone/p/6852241.html

int 32位占4个字节，一般由计算机的字长决定
long 32位  在32位机器上，64则8字节
指针--32位  在32位机器，64则8字节
//这2个是32与64机器的区别
short 16位
unsigned int 32 bit
short int 16位占2个字节（-32768～32767 ）
long int占 32位4个字节 （-2147483648～2147483647 ）
long long 64位

float 32位（单精度型）6位有效数字
double 64位（双精度型） 15位有效数字 精确度和值域都高于float
long double 96位gcc（长双精度型）

fabs(x-y) < 1e-6//浮点数比较常用


char  8位 8bit
char c='\48'; 八进制ASCII码字
unsigned char 

反斜杠（\）应写成：'\\'
单引号（'）应写成：'\''
双引号（"）可写成：'\"'

// 浮点数类型：
直接比较浮点数与零值可能会出现问题，因为浮点数的精度限制可能导致微小的误差。所以，不建议直接使用等号 `==` 进行浮点数和零值的比较。
要比较浮点数和零值，可以使用一个小的阈值来检查它们之间的差异，例如：
float a = 0.1 + 0.2;
float epsilon = 1e-6; // 适当的阈值，一个很小的数
if (fabs(a - 0.3) < epsilon) { // 绝对值
    // 执行处理
}
在这里，`fabs` 函数用于获取绝对值，而 `epsilon` 是一个适当的小值，用来表示可以接受的误差范围。

```

**枚举类型**

https://www.cnblogs.com/JCSU/articles/1299051.html

```c
枚举类型
本质就是整型常量
第一个枚举成员的默认值为整型的0，后续枚举成员的值在前一个成员上加1。

三种定义：
enum Color {RED, YELLOW, BLUE};
Color c1, c2, c3;//c++写法
enum Color c1;//c语言写法

enum Color//跟第一个定义不同的是，此处的标号color省略，这是允许的。
{
   RED, YELLOW=4, BLUE
} haha，heihei; //变量haha的类型为枚举型enum Color

typedef enum Color {RED, YELLOW, BLUE}ccl;
//ccl为枚举型enum Color的别名;
ccl haha= red; //c与c++都一样？注意此时ccl不是一个变量，是类型

```

**C数据类型转换**

https://blog.csdn.net/cherish\_2012/article/details/21243047

看最后总结

```c
1、隐式转换
    C在以下四种情况下会进行隐式转换:
    1、算术运算式中，低类型能够转换为高类型。
    2、赋值表达式中，右边表达式的值自动隐式转换为左边变量的类型，并赋值给他。
    3、函数调用中参数传递时，系统隐式地将实参转换为形参的类型后，赋给形参。
    4、函数有返回值时，系统将隐式地将返回表达式类型转换为返回值类型，赋值给调用函数。
2、算数运算的隐式转换//包括大小比较
    算数运算中，首先有如下类型转换规则：
    1、字符必须先转换为整数(C语言规定字符类型数据和整型数据之间可以通用) 。
    2、short型转换为int型(同属于整型) 。
    3、float型数据在运算时一律转换为双精度(double)型，以提高运算精度(同属于实型) 。
其次，有下面的规则。
高long double
	double
	float
	unsigned long
	long
	unsigned
  int
低（short, char）
//被高优先级转化,范围小的隐式转换为范围大的
unsigned默认是unsigned int !!!!!!
同类型符号有无不同时：
int会被unsigned int转换
char被unsigned char转换


//随机数设置
srand((int)time(0));
cout<<rand()%x;//0--x范围
```

**数组**

```c
int a[6] = {1, 2, 3}; //后面默认初始化为0
数组函数
int Max(int x[ ], int num){} //形参习惯x[]，传递地址！！！
int a[10]=....;
Func(a,n);


二维数组可以省略行数
int b[][2] = {{0,1}, {2,3}, {4,5}};
未指定的元素都为0
int b[3][2] = {0, 1, 2, 4, 5};	//第3行第2列元素为0
int b[3][2] = {{0,1}, {2}, {4,5}};	//第2行第2列元素为0
二维数组可看作一维数组(因为内存分布是线性的)：
用 *(b[2]+x*i+j) 获得元素值
*b是一个普通的int指针，相当于b[0]，指向第一行第一个元素。
b相当于一个指针(和指针唯一不同就是b自己不能++，因为数组名仅仅是个常量)，但是b是一个int*[2]类型的指针，它+1等于前进1行。
**b就相当于b[0][0]，等于真正的值了。


sizeof(b)返回24，及6个元素，每个4字节。
// 我的理解，这里没有涉及到二级指针，因为b和*b输出的值是一样的，及同一块地址如0x16b333070，只是+-时步长不一样。b由于可以添加2个*所以显得像二级指针。


二维数组函数
int Sum(int x[ ][N], int lin){} //N必须形参实参一致
或
int Sum(int x[ ], int num){}
Sum(m1[0], 10 * 5);//当成一维数组遍历每个元素

二维数组取地址例子
int app[4][2]={1,2,3,4,5,6};
cout<< app;        //0x7ffeefbff630
cout<< *app;       //0x7ffeefbff630
cout<< **app;      //1
cout<< *(app+1);   //0x7ffeefbff638 地址前进一个单位，即一行（int*[2]类型指针的加减）
cout<< **(app+1);  //3

cout<< app[0];     //0x7ffeefbff630
cout<< *app[0];    //1
cout<< app[0]+1;   //0x7ffeefbff634 地址前进一个元素
cout<< *(app[0]+1);//2
//查看指针章节



```