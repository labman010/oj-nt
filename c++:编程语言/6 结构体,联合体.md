**C语言结构体**

```c
// =============== 结构体定义与声明 =============== 
// (详见 02声明和定义)
struct Student {
    int id;
    char name[50];
    float grade;
}; // 结构体本身的定义
struct Student student1; // [C语言]声明了一个Student类型的结构体变量student1，

// =============== 结构体初始化和赋值 =============== 
// 1.直接初始化所有成员
struct Student student2 = {100, "Alice", 85.5};

// 2.定义后逐个赋值(常见，略过)

// 3.定义时乱序赋值（C风格）
struct InitMember test = {
    .second = 3.141590,
    .third = "method three",
    .first = -10,
    .four = 0.25
};

// 4.定义时乱序赋值（GNU old-style field designator extension）
struct InitMember test = {
    second：3.141590,
    third："method three",
    first：-10,
    four：0.25
};

// 直接赋值。相同结构类型的不同变量之间可以直接相互赋值，其实质是两个结构变量相应的存储空间中的所有成员数据直接拷贝
Student s1,s2;
s1 = s2;

// 结构体数组。
Student stu_array[5];	//定义了一个结构数组
Student stu_array[5] = { {1001, "123"},...,{1005, 'L',  'F',  18，81.0} }; 

// 匿名结构体实例化(特殊)
// 解析：结构体定义和变量声明是合并在一条语句中完成的，而且没有给结构体本身起名字，仅通过一次声明和初始化操作就创建了具有特定成员的结构体实例。
// 由于匿名结构体没有名称，所以不能像有名结构体那样多次声明新的同类型变量，每次需要使用时都必须重新定义其完整的结构体内容。不过匿名结构体常用于临时或局部用途，或者嵌套在其他结构体、联合体内部作为成员。
struct {
    int age;
    char name[50];
} person; 
// 或：
struct {
    int age;
    char name[50];
} person = {123, "123"}; 


// PS： 结构类型不可以含有本结构类型成员。但结构类型可以含有本结构类型的指针成员。
```

**C++中的结构体**

<https://www.cnblogs.com/starfire86/p/5367740.html>

```c
// 首先使用结构体无需加struct
struct Student {
    int id;
    char name[50];
    float grade;
};
Student student1;

// C++结构体成员可以在声明结构体实例时进行初始化，而C语言中通常需要在定义后单独初始化。// (详见 02声明和定义)

// C++允许结构体内包含成员函数，这使得C++的结构体可以具有面向对象的行为，类似于类。可以包含成员函数、继承、多态。
// C++中，结构体可以拥有构造函数和析构函数，用于在创建和销毁对象时执行特定的操作。
// C++中结构体成员默认也是public，但它支持public、private和protected三种访问控制级别。即使在结构体中，也可以使用这些访问修饰符来控制成员变量和成员函数的访问权限。

```

**struct 对齐 **

总结：

该问题总结为两条规律： 

1，每个结构体成员的起始地址为该成员大小的整数倍，即int型成员的起始地址只能为0、4、8等。 

2，结构体的大小为其中最大成员大小的整数倍，不满足的话要在后面补充。

//数组以其数据类型为准。

3.可以使用关键词\#pragma pack(1)来指定结构体的对齐值。//加在结构体前

4.有效对齐值为自身对齐值与指定对齐值中较小的一个。（即指定对齐值超过自身对齐值无意义）

**联合体 union **

当多个数据需要共享内存或者多个数据每次只取其一时，可以利用联合体(union)。在C Programming Language 一书中对于联合体是这么描述的：

1)联合体是一个结构；

2)它的所有成员相对于基地址的偏移量都为0；

3)此结构空间要大到足够容纳最"宽"的成员；

4)其对齐方式要适合其中所有的成员；

联合体中的所有成员是共享一段内存的。

对于这句“对齐方式要适合其中所有的成员”是指其必须符合所有成员的自身对齐方式。

```c
union U
{
    char s[9];
    int n;
    double d;
};

s占9字节，n占4字节，d占8字节，因此其至少需9字节的空间。然而其实际大小并不是9，用运算符sizeof测试其大小为16.这是因为这里存在字节对齐的问题，9既不能被4整除，也不能被8整除。因此补充字节到16，这样就符合所有成员的自身对齐了。从这里可以看出联合体所占的空间不仅取决于最宽成员，还跟所有成员有关系，即其大小必须满足两个条件：
1)大小足够容纳最宽的成员
2)大小能被其包含的所有基本数据类型的大小所整除。


```

Union 位域(bit-fields)语法

```c
// 定义 8 位无符号整数类型
typedef unsigned char u8;

// 定义联合体 inst，并使用 typedef 将其定义为 inst_t 类型
typedef union inst {
    struct { u8 rs : 2, rt: 2, op: 4; } rtype;
    struct { u8 addr: 4, op: 4; } mtype;
} inst_t;
// 这叫“位域”的语法，用于定义结构体中的成员。位域允许您在结构体中指定每个成员所占用的位数。
// 在内存中，位域通常是按照从最低有效位（LSB）到最高有效位（MSB）的顺序排列的，而不是按照在结构体中的声明顺序排列的。这是因为位域的布局是由编译器决定的，并且通常会尽量优化内存布局以提高效率。

```