**extern**

// 见 《2 声明,定义,初始化》

**static**

static 表示静态的变量，分配内存的时候, 存储在数据段，所以声明定义同时进行。

1. 在局部变量的定义中，static修饰符用于指定局部变量采用静态存储分配。它只在第一次调用时进行初始化，以后调用中不再进行初始化，它的值为上一次调用结束时的值。
  1. 此局部变量离开作用域时，变量名无法使用了，但是它的内存占用空间和内容还在，可以通过指针调用。
2. 在全局变量的定义中，static修饰符用于把全局标识符的作用域改变为文件作用域。它们只能在定义它们的源文件（模块）中使用。
  1. 一般定义static全局变量时，都把它放在原文件中而不是头文件，这样就不会给其他模块造成不必要的信息污染。
  2. 头文件中static声明的变量，在不同cpp中用到，在内存中实际存在了两份拷贝给两个模块中的变量使用。
  3. 在同一个文件中声明两遍，如 **static int dummy; **不会有报错，但是都改为 **static int dummy = 0;** (可以加个volatile确保)则是重定义错误。——（在C语言中只声明不初始化是一种弱定义，当声明多个同名同类型的变量时，编译不会报错，但是到了链接阶段，由于全是弱符号，链接器会随便选择一个。而如果已经都初始化了，这变成了强定义，编译器无法忽略）
  4. 

(static 变量在类内部声明，但是必须在类的外部进行定义和初始化)

C++类的成员变量和成员函数相关static见【7对象和类】

**const**

c++中const局部变量在程序运行时是否分配了内存有两种观点：。。。

```c
const int m = 0; // m为整型常量，其值不可以改变
const int m;   //编译错误,用const定义常量时必须同时初始化
const int *p1; // 合理。常量指针，代表这个指针指向的变量类型必须是const int。
int n = 0;
p1 = &n; //合理，等于n在p1这里强制类型转换变成了常量，不能通过p1修改n的值。
n++;    // OK,可以直接通过n改变n的值。

int * const p2 = &n; //p2是指向变量的指针常量，其值不可以改变(不能再指向别的地址了)，*p2的值可以改变。
const int * const p3 = &m; //都不可改,可以通过其他指针改变m。
//解析：一个const紧挨变量名字，说明是针对指针本身的不能修改。另一个一个const紧挨int，代表是针对指针指向的int值不能修改。

```

<https://blog.csdn.net/SMF0504/article/details/52311207>

const成员特点：

* 类中的const成员本质是只读变量，和普通成员变量一样，跟随对象存在于对应的内存上(堆\\栈...)。
* const 成员常量在类内部声明，但是定义只能在构造函数的初始化列表进行。

C++类的成员变量和成员函数相关const见【7对象和类】，包括const成员常量。

### 

---

### 概念

[编译单元](https://baike.baidu.com/item/%E7%BC%96%E8%AF%91%E5%8D%95%E5%85%83/7400939?fr=aladdin)

全局变量：一个在所有函数之外定义的变量具有文件作用域，从定义开始到包含该文件结尾都可见，文件作用域变量也称为**全局变量**。